using NewHorizons.Utility;
using OWML.Utils;
using System;
using System.Collections.Generic;
using UnityEngine;

namespace FifthModJam
{

    public class QuantumPuzzle : MonoBehaviour
    {
        private enum SocketsFilledMask
        {
            None = 0,
            SocketOne = 1,
            SocketTwo = 2,
            SocketThree = 4,
        }
        private SocketsFilledMask _socketsFilledMask;

        [SerializeField]
        private CustomItemSocket[] customItemSockets = new CustomItemSocket[2];
        [SerializeField]
        private GameObject[] quantumGeysers = new GameObject[4]; // [Note: 012 are gameobjects holding quantum sets generated by nh, 3 is the solution non-quantum geyser]
        private bool hasCompletedQuantumPuzzle;

        private Dictionary<SocketsFilledMask, int> _geyserStatesDict = new()
        {
            { SocketsFilledMask.None, 0},
            { SocketsFilledMask.SocketOne, 2}, // [Note: minor inconsistency due to how the unity setup was filled, but this works just fine and can be changed whenever]
            { SocketsFilledMask.SocketTwo, 1},
            { SocketsFilledMask.SocketTwo | SocketsFilledMask.SocketOne, 3}, // Both sockets are filled

            // [Note: Should we add a third socket or more, here's the prep for the states]
            { SocketsFilledMask.SocketThree, 4 },
            { SocketsFilledMask.SocketThree | SocketsFilledMask.SocketOne, 5 },
            { SocketsFilledMask.SocketThree | SocketsFilledMask.SocketTwo, 6 },
            { SocketsFilledMask.SocketThree | SocketsFilledMask.SocketTwo | SocketsFilledMask.SocketOne, 7 },
        };
        private int _currentState;

        private void Start()
        {
            hasCompletedQuantumPuzzle = false;
            _socketsFilledMask = SocketsFilledMask.None;
            _currentState = 0;
            SwapGeyser(_currentState);
        }

        private void Awake()
        {
            // Link each socket to trigger their OnSocketFilled and OnSocketRemove
            // [Note: The big lines are the equivalent of a += but with events]
            var socketOne = customItemSockets[0];
            socketOne.OnSocketablePlaced = (OWItemSocket.SocketEvent)Delegate.Combine(socketOne.OnSocketablePlaced, new OWItemSocket.SocketEvent(OnSocketOneFilled));
            socketOne.OnSocketableRemoved = (OWItemSocket.SocketEvent)Delegate.Combine(socketOne.OnSocketableRemoved, new OWItemSocket.SocketEvent(OnSocketOneRemoved));

            var socketTwo = customItemSockets[1];
            socketTwo.OnSocketablePlaced = (OWItemSocket.SocketEvent)Delegate.Combine(socketTwo.OnSocketablePlaced, new OWItemSocket.SocketEvent(OnSocketTwoFilled));
            socketTwo.OnSocketableRemoved = (OWItemSocket.SocketEvent)Delegate.Combine(socketTwo.OnSocketableRemoved, new OWItemSocket.SocketEvent(OnSocketTwoRemoved));
        }
        private void OnSocketOneFilled(OWItem item)
        {
            _socketsFilledMask |= SocketsFilledMask.SocketOne; // Adding the SocketOne bit
            UpdateGeysers();
        }
        private void OnSocketOneRemoved(OWItem item)
        {
            _socketsFilledMask &= ~SocketsFilledMask.SocketOne; // Removing the SocketOne bit
            UpdateGeysers();
        }
        private void OnSocketTwoFilled(OWItem item)
        {
            _socketsFilledMask |= SocketsFilledMask.SocketTwo; // Adding the SocketTwo bit
            UpdateGeysers();
        }
        private void OnSocketTwoRemoved(OWItem item)
        {
            _socketsFilledMask &= ~SocketsFilledMask.SocketTwo; // Removing the SocketTwo bit
            UpdateGeysers();
        }

        public void SwapGeyser(int index)
        {
            // Only activate the set of quantum geysers that matches the index, the other sets are inactive
            for (int i = 0; i < quantumGeysers.Length; i++)
            {
                quantumGeysers[i].SetActive(i == index);
            }

            _currentState = index;
        }

        private void UpdateGeysers()
        {
            // Get the state corresponding to the current socket configuration (checking the lookup table) and swap to that state
            var index = _geyserStatesDict[_socketsFilledMask];
            SwapGeyser(index);

            // If we want to do something when we get into a specific state, put it here (in this case state 3 being the solution)
            if (_currentState == 3)
            {
                hasCompletedQuantumPuzzle = true; // [Note: Doesn't do anything right now, this is just an example that can be deleted later]
            }
        }
    }
}